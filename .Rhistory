# Code used to fit intergrated LRP models using MCMC in stan
# For stantmb example, see: https://github.com/kaskr/tmbstan#examples
nIter<-10000
estSgen<-FALSE
library(dplyr)
library(TMB)
library(tmbstan)
library(tidyverse)
# read in data
CoEscpDat <- read.csv("IFCoho_escpByCU.csv")
CoSRDat <- read.csv("IFCoho_SRbyCU.csv")
TMB::compile("TMB_Files/SR_IndivRicker_Surv_noLRP.cpp")
dyn.load(dynlib("TMB_Files/SR_IndivRicker_Surv_noLRP"))
compile("TMB_Files/SR_HierRicker_Surv_noLRP.cpp")
dyn.load(dynlib("TMB_Files/SR_HierRicker_Surv_noLRP"))
compile("TMB_Files/SR_IndivRicker_SurvCap_noLRP.cpp")
dyn.load(dynlib("TMB_Files/SR_IndivRicker_SurvCap_noLRP"))
compile("TMB_Files/SR_HierRicker_SurvCap_noLRP.cpp")
dyn.load(dynlib("TMB_Files/SR_HierRicker_SurvCap_noLRP"))
compile("TMB_Files/SR_IndivRicker.cpp")
dyn.load(dynlib("TMB_Files/SR_IndivRicker"))
# Change header names to match generic data headers (this will allow generic functions from Functions.r to be used)
colnames(CoEscpDat)[colnames(CoEscpDat)=="CU_ID"] <- "CU"
colnames(CoEscpDat)[colnames(CoEscpDat)=="MU_Name"] <- "MU"
colnames(CoEscpDat)[colnames(CoEscpDat)=="ReturnYear"] <- "yr"
colnames(CoEscpDat)[colnames(CoEscpDat)=="Escapement"] <- "Escp"
# Restrict data set to years 1998+ based on recommendation from Michael Arbeider
CoEscpDat <- CoEscpDat %>% filter(yr >= 1998)
CoSRDat <- CoSRDat %>% filter(BroodYear >= 1998)
# Prep data frame
CoSRDat$yr_num <- CoSRDat$BroodYear - min(CoSRDat$BroodYear)
CoSRDat$CU_ID <- CoSRDat$CU_ID - 1
CoEscpDat$yr_num <- CoEscpDat$yr- min(CoEscpDat$yr)
CoEscpDat<- CoEscpDat %>% right_join(unique(CoSRDat[,c("CU_ID", "CU_Name")]))
SRDat<-CoSRDat
EscDat <- CoEscpDat
# Start MCMC fit ==========================================
# Option 1) Fit hierarchical model with survival covariate; no LRP estimation
# Mod <- "SR_HierRicker_Surv_noLRP"
#  TMB_Inputs <- list(Scale = 1000, logA_Start = 1, logMuA_mean = 1,
#                        logMuA_sig = sqrt(2), Tau_dist = 0.1, Tau_A_dist = 0.1,
#                        gamma_mean = 0, gamma_sig = 10, S_dep = 1000, Sgen_sig = 1)
#
# # Option 2) Fit individual models with survival covariate; no LRP estimation
Mod <- "SR_IndivRicker_Surv_noLRP"
TMB_Inputs <- list(Scale = 1000, logA_Start = 1,
Tau_dist = 0.1,
gamma_mean = 0, gamma_sig = 10, S_dep = 1000, Sgen_sig = 0.5)
# Option 4) Fit hierarchical model with survival covariate and capacity cap; no LRP estimation
# Mod <- "SR_HierRicker_SurvCap_noLRP"
# cap_priorMean_HM<-c(10.957092, 5.565526, 11.467815, 21.104274, 14.803877)
#
# TMB_Inputs <- list(Scale = 1000, logA_Start = 1, logMuA_mean = 1,
#                                logMuA_sig = sqrt(2), Tau_dist = 0.1, Tau_A_dist = 0.1,
#                                gamma_mean = 0, gamma_sig = 10, S_dep = 1000, Sgen_sig = 1,
#                                cap_mean=cap_priorMean_HM, cap_sig=sqrt(2))
# Option 5) Fit individual models with survival covariate and capacity cap; no LRP estimation
# Mod <- "SR_IndivRicker_SurvCap_noLRP"
# cap_priorMean_IM<-c(11.153583,  5.714955, 11.535779, 21.379558, 14.889006)
# TMB_Inputs <- list(Scale = 1000, logA_Start = 1, Tau_dist = 0.1,
#                    gamma_mean = 0, gamma_sig = 10, S_dep = 1000, Sgen_sig = 1,
#                    cap_mean=cap_priorMean_IM, cap_sig=sqrt(2))
# Set-up for call to TMB
Scale <- TMB_Inputs$Scale
data <- list()
data$S <- SRDat$Spawners/Scale
data$logR <- log(SRDat$Recruits/Scale)
data$stk <- as.numeric(SRDat$CU_ID)
N_Stocks <- length(unique(SRDat$CU_Name))
data$N_Stks <- N_Stocks
data$yr <- SRDat$yr_num
data$Sgen_sig <- TMB_Inputs$Sgen_sig # set variance to be used for likelihood for estimating Sgen
data$BiasCorrect <-0
data$Bayes<-1
# set-up init params
param <- list()
param$logA <- rep(TMB_Inputs$logA_Start, N_Stocks)
param$logSigma <- rep(-2, N_Stocks)
param$logSgen <-  log((SRDat %>% group_by(CU_Name) %>%  summarise(x=quantile(Spawners, 0.5)))$x/Scale)
data$Tau_dist <- TMB_Inputs$Tau_dist
#param <- list()
#param$logA <- rep(TMB_Inputs$logA_Start, N_Stocks)
#param$logB <- log(1/( (SRDat %>% group_by(CU_ID) %>% summarise(x=quantile(Spawners, 0.8)))$x/Scale) )
#param$logSigma <- rep(-2, N_Stocks)
#param$logSgen <-  log((SRDat %>% group_by(CU_Name) %>%  summarise(x=quantile(Spawners, 0.5)))$x/Scale)
if (Mod %in% c("SR_HierRicker_Surv_noLRP", "SR_IndivRicker_Surv_noLRP","SR_HierRicker_SurvCap_noLRP", "SR_IndivRicker_SurvCap_noLRP" )) {
param$gamma <- 0
}
# specify data
data$P_3 <- SRDat$Age_3_Recruits/SRDat$Recruits
if (Mod %in% c("SR_HierRicker_Surv_noLRP","SR_IndivRicker_Surv_noLRP","SR_HierRicker_SurvCap_noLRP","SR_IndivRicker_SurvCap_noLRP")) {
data$logSurv_3 <- log(SRDat$STAS_Age_3)
data$logSurv_4 <- log(SRDat$STAS_Age_4)
#muSurv <- SRDat %>% group_by(CU_ID) %>%
#summarise(muSurv = mean(STAS_Age_3*(Age_3_Recruits/Recruits) + STAS_Age_4*(Age_4_Recruits/Recruits)))
#data$muLSurv <- log(muSurv$muSurv)
# Base mu survival on mean of age 3 survival (not weighted by historic age at return)
muLSurv<-SRDat  %>% group_by(CU_ID) %>% summarise(muLSurv=mean(log(STAS_Age_3)))
data$muLSurv <- muLSurv$muLSurv
}
data$Tau_dist <- TMB_Inputs$Tau_dist
if (Mod %in% c("SR_HierRicker_Surv_noLRP","SR_HierRicker_SurvCap_noLRP")) {
data$logMuA_mean <- TMB_Inputs$logMuA_mean
data$logMuA_sig <- TMB_Inputs$logMuA_sig
data$Tau_A_dist <- TMB_Inputs$Tau_A_dist
param$logMuA <- TMB_Inputs$logA_Start
param$logSigmaA <- 1
}
if (Mod %in% c("SR_HierRicker_Surv_noLRP","SR_IndivRicker_Surv_noLRP","SR_HierRicker_SurvCap_noLRP","SR_IndivRicker_SurvCap_noLRP")) {
data$gamma_mean <- TMB_Inputs$gamma_mean
data$gamma_sig <- TMB_Inputs$gamma_sig
}
# add data and parameters specific to models with carrying capacity prior:
if(Mod %in% c("SR_HierRicker_SurvCap_noLRP", "SR_IndivRicker_SurvCap_noLRP")) {
param$cap <- TMB_Inputs$cap_mean
data$cap_mean<-TMB_Inputs$cap_mean
data$cap_sig<-TMB_Inputs$cap_sig
}
# add parameter specific to model without cap on carrying capacity (model parameterized for B):
if(Mod %in% c("SR_HierRicker_Surv_noLRP", "SR_IndivRicker_Surv_noLRP")) {
param$logB <- log(1/( (SRDat %>% group_by(CU_ID) %>% summarise(x=quantile(Spawners, 0.8)))$x/Scale) )
}
# range of spawner abundance to predict recruitment from
data$Pred_Spwn <- rep(seq(0,max(data$S)*1.1,length=100), N_Stocks) # vectors of spawner abundance to use for predicted recruits, one vector of length 100 for each stock
for (i in 1:N_Stocks) { # make a vector of same length as Pred_Spwn with CU ids
if (i == 1) {
data$stk_predS <- rep(unique(SRDat$CU_ID)[1],100)
} else {
data$stk_predS<-c(data$stk_predS,rep(unique(SRDat$CU_ID)[i],100))
}
}
# Phase 1 estimate SR params ============
map <- list(logSgen=factor(rep(NA, data$N_Stks))) # Fix Sgen
if (Mod %in% c("SR_HierRicker_Surv_noLRP","SR_HierRicker_SurvCap_noLRP")) {
obj <- MakeADFun(data, param, DLL=Mod, silent=TRUE, random = "logA", map=map)
} else {
obj <- MakeADFun(data, param, DLL=Mod, silent=TRUE,  map=map)
}
opt <- nlminb(obj$par, obj$fn, obj$gr, control = list(eval.max = 1e5, iter.max = 1e5))
pl <- obj$env$parList(opt$par) # Parameter estimate after phase 1
opt
pl
# -- pull out SMSY values
All_Ests <- data.frame(summary(sdreport(obj)))
All_Ests
All_Ests$Param <- row.names(All_Ests)
All_Ests
SMSYs <- All_Ests[grepl("SMSY", All_Ests$Param), "Estimate" ]
SMSYs
pl$logSgen <- log(0.3*SMSYs)
pl$logSgen
# Phase 2 get Sgen, SMSY etc. =================
if (Mod %in% c("SR_HierRicker_Surv_noLRP","SR_HierRicker_SurvCap_noLRP")) {
if (estSgen == TRUE) obj <- MakeADFun(data, pl, DLL=Mod, silent=TRUE, random = "logA")
if (estSgen == FALSE) obj <- MakeADFun(data, pl, DLL=Mod, silent=TRUE, random = "logA", map=map)
} else {
if (estSgen == TRUE) obj <- MakeADFun(data, pl, DLL=Mod, silent=TRUE)
if (estSgen == FALSE) obj <- MakeADFun(data, pl, DLL=Mod, silent=TRUE, map=map)
}
# Create upper bounds vector that is same length and order as start vector that will be given to nlminb
upper<-unlist(obj$par)
upper[1:length(upper)]<-Inf
if (estSgen == TRUE) upper[names(upper) =="logSgen"] <- log(SMSYs) # constrain Sgen to be less than Smsy
#upper[names(upper) =="cap"] <- SMSYs * 10 # constrain Sgen to be less than 10x Smsy
upper<-unname(upper)
lower<-unlist(obj$par)
lower[1:length(lower)]<--Inf
if (estSgen == TRUE) lower[names(lower) =="logSgen"] <- log(0.01)
lower[names(lower) =="cap"] <- 0
lower<-unname(lower)
